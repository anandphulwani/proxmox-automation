- name: "Declare all variables"
  set_fact:
    file_sno_type_prefix: "{{ '%02d' | format(pretask_taskandtaskcondition_message_sno | int) }}-Task:"
    section_name: "`Setting up LAN and Internet Bridge`"
  changed_when: false

- name: "{{ file_sno_type_prefix }} 001: {{ section_name }}, Added values to `DHCP range` for DHCP"
  replace:
    path: /etc/dnsmasq.conf
    regexp: "\
      #\\s*\
      dhcp-range\\s*=\\s*\
      (?:\
        (?:\
          (?:\
            \\d{1,3}\\.\
          ){3}\\d{1,3}\
        ),\
      ){3}\
      \\d{1,3}h"
    replace: "dhcp-range={{ dhcp_range_from }},{{ dhcp_range_to }},{{ subnet_mask }},6h"

- name: "{{ file_sno_type_prefix }} 002: {{ section_name }}, Added values to `default gateway` for DHCP"
  replace:
    path: /etc/dnsmasq.conf
    regexp: "\
      #\\s*\
      dhcp-option\\s*=\\s*\
      3\\s*,\\s*\
      (?:\
        (?:\
          \\d{1,3}\\.\
        ){3}\\d{1,3}\
      )"
    replace: "dhcp-option=3,{{ default_gateway }}"

- name: "{{ file_sno_type_prefix }} 003: {{ section_name }}, Added values to `DNS servers` for DHCP"
  lineinfile:
    path: "/etc/dnsmasq.conf"
    regexp: '^\s*#\s*dhcp-option\s*=\s*6\s*,\s*=.*$'
    line: 'dhcp-option=6,{{ dns_server_01 }},{{ dns_server_02 }}'
    state: present
    insertafter: EOF

- name: "{{ file_sno_type_prefix }} 004: {{ section_name }}, Modify `/etc/network/interfaces` to add `vmbr0B_LANnInt`"
  replace:
    path: /etc/network/interfaces
    regexp: "\
      (\
      auto vmbr0B_LANnInt\\n\
      iface vmbr0B_LANnInt .*\\n\
      )\
      (\
        (?!\taddress )\
        [\\s\\S]*?\
      )\
      (\\n\\s*\\n)\
      "
    replace: "\
      auto vmbr0B_LANnInt\n\
      iface vmbr0B_LANnInt inet static\n\
      \taddress {{ default_gateway }}\n\
      \tnetmask {{ subnet_mask }}\n\
      \\2\n\
      \t# LAN and Internet connection\n\
      \t# Enabling Internet via NAT MASQUERADE\n\
      \tpost-up echo 1 > /proc/sys/net/ipv4/ip_forward\n\
      \tpost-up iptables -t nat -A POSTROUTING -o vmbr0A_mainbrg -j MASQUERADE\n\
      \tpost-up iptables -A FORWARD -i vmbr0B_LANnInt -o vmbr0A_mainbrg -j ACCEPT\n\
      \tpost-up iptables -A FORWARD -i vmbr0A_mainbrg -o vmbr0B_LANnInt -m state --state RELATED,ESTABLISHED -j ACCEPT\n\
      \t# Firewall Rules\n\
      \t# Port forwarding sample: Public IP: 10022 -----> Private IP: 22\n\
      \t# post-up iptables -t nat -A POSTROUTING -s '{{ vmbr0B_iprange }}' -o vmbr0A_mainbrg -j MASQUERADE\n\
      \t# post-up iptables -t nat -A PREROUTING -i vmbr0A_mainbrg -p tcp --dport 10022 -j DNAT --to {{ sample_client_ip }}:22\n\
      \t# post-down iptables -t nat -D POSTROUTING -s '{{ vmbr0B_iprange }}' -o vmbr0A_mainbrg -j MASQUERADE\n\
      \t# post-down iptables -t nat -D PREROUTING -i vmbr0A_mainbrg -p tcp --dport 10022 -j DNAT --to {{ sample_client_ip }}:22\n\
      \\3"

- name: "{{ file_sno_type_prefix }} 005: {{ section_name }}, Create `dhcp_static_mappings_generator.sh` file and append content to it"
  copy:
    dest: "/usr/local/bin/dhcp_static_mappings_generator.sh"
    content: |
      {% raw %}
      #!/bin/bash

      # This script updates the DHCP static lease entries in `/etc/dnsmasq.conf` for Proxmox virtual machines (VMs)
      # whose configurations have changed since the last update of the `dnsmasq` configuration.
      #
      # **Usage**: `./script_name.sh <ip_ranges_with_subnet_prefix>`
      #
      # **Purpose**:
      # The script automates the management of static IP assignments for VMs by parsing their configuration files,
      # extracting network interface MAC addresses, and generating corresponding `dhcp-host` entries in `dnsmasq.conf`.
      # This ensures that VMs consistently receive the same IP addresses based on their configurations.
      #
      # **Workflow**:
      # 1. **Argument Check**: Verifies that the `<ip_ranges_with_subnet_prefix>` argument is provided, which should be one of:
      #    - `10.0.0.0/8`
      #    - `172.16.0.0/16`
      #    - `192.168.0.0/16`
      #    If an invalid range is provided, the script exits with an error message.
      #
      # 2. **Identify Changed VM Configurations**: Finds VM configuration files in `/etc/pve/qemu-server` that have been modified more recently than `/etc/dnsmasq.conf`.
      #
      # 3. **Initialize Data Structures**: Sets up an associative array to track unique MAC addresses and an array to store new DHCP entries.
      #
      # 4. **Process Each Changed VM Configuration**:
      #    - Extracts the VMID from the configuration file name.
      #    - Parses network interface definitions to extract unique MAC addresses.
      #    - **IP Address Construction**:
      #      - For `/8` subnet (e.g., `10.0.0.0/8`):
      #        Constructs IP addresses using the pattern: `<first_block_ip>.<first_digit_of_VMID>.<last_two_digits_of_VMID>.<interface_order>`.
      #        For example, with `first_block_ip=10` and `VMID=101`, the IP might be `10.1.01.1`.
      #      - For `/16` subnet (e.g., `172.16.0.0/16` or `192.168.0.0/16`):
      #        Constructs IP addresses using the pattern: `<first_block_ip>.<second_block_ip>.<first_two_digits_of_VMID>.<last_digits_of_VMID><interface_order>`.
      #        For example, with `first_block_ip=172`, `second_block_ip=16`, and `VMID=568`, the IP might be `172.16.56.81`.
      #    - Builds `dhcp-host` entries linking each MAC address to its generated IP address.
      #
      # 5. **Remove Old Static Leases**: Cleans up outdated `dhcp-host` entries in `/etc/dnsmasq.conf` for the changed VMs to prevent duplicates.
      #
      # 6. **Generate New DHCP Entries**: Compiles the new `dhcp-host` lines into a variable for insertion.
      #
      # 7. **Update dnsmasq Configuration**: Inserts the new DHCP entries into `/etc/dnsmasq.conf` under the `# DHCP Static leases` section.
      #
      # **Outcome**:
      # - VMs receive consistent and predictable IP addresses based on their VMIDs and network interface order.
      # - The `dnsmasq` service has an updated configuration that reflects the current state of VM network interfaces.
      # - Simplifies network management in virtualized environments by automating IP assignment tasks.

      # Step 1: Check if the ip_ranges_with_subnet_prefix argument is passed
      if [ -z "$1" ]; then
          echo "Usage: $0 <ip_ranges_with_subnet_prefix>"
          exit 1
      fi

      ip_ranges_with_subnet_prefix="$1"

      # Validate the input
      if [[ "$ip_ranges_with_subnet_prefix" != "10.0.0.0/8" && "$ip_ranges_with_subnet_prefix" != "172.16.0.0/16" && "$ip_ranges_with_subnet_prefix" != "192.168.0.0/16" ]]; then
          echo "Invalid IP range with subnet prefix. Allowed values are 10.0.0.0/8, 172.16.0.0/16, or 192.168.0.0/16"
          exit 1
      fi

      # Extract the first and second block IPs and subnet prefix
      IFS='/' read -r ip_range subnet_prefix <<< "$ip_ranges_with_subnet_prefix"
      IFS='.' read -r first_block_ip second_block_ip _ _ <<< "$ip_range"

      # Step 2: Find VM configuration files newer than /etc/dnsmasq.conf
      changed_files=( $(find -L /etc/pve/qemu-server -type f -name '*.conf' -newer /etc/dnsmasq.conf | sort) )

      if [ ${#changed_files[@]} -eq 0 ]; then
          exit 0
      fi

      # Step 3: Initialize associative array and entries list
      declare -A mac_addresses
      entries=()

      # Step 4: Process each changed VM configuration file
      for conf_file in "${changed_files[@]}"; do
          order_no=1
          vmid=$(basename "$conf_file" .conf)

          # Extract digits from VMID based on subnet prefix
          if [[ "$subnet_prefix" == "8" ]]; then
              part1=${vmid:0:1}
              part2=${vmid:1:2}
          else
              part1=${vmid:0:2}
              part2=${vmid:2}
          fi

          # Use grep to extract all matching lines, and then sort them
          matching_lines=$(grep -E '^net[0-9]{1,4}:[^=]*=\s*([^,]*),.*' "$conf_file" | sort)

          # Filter out duplicates by MAC address first
          unique_lines=()
          while IFS= read -r line; do
              if [[ $line =~ ^(net[0-9]{1,4}):[^=]*=\s*([^,]*),.* ]]; then
                  mac="${BASH_REMATCH[2]}"

                  # Only process unique MAC addresses
                  if [[ -n "$mac" && -z "${mac_addresses[$mac]}" ]]; then
                      mac_addresses["$mac"]=1
                      unique_lines+=("$line")
                  fi
              fi
          done <<< "$matching_lines"

          # Process the unique lines
          for line in "${unique_lines[@]}"; do
              if [[ $line =~ ^(net[0-9]{1,4}):[^=]*=\s*([^,]*),.* ]]; then
                  net_number="${BASH_REMATCH[1]}"
                  mac="${BASH_REMATCH[2]}"
                  net_num_only="${net_number#net}"

                  entries+=("$net_num_only|$mac|$part1|$part2|$order_no")
                  ((order_no++))
              fi
          done
      done

      # Step 6: Modify /etc/dnsmasq.conf to remove old static leases for each changed VM
      for conf_file in "${changed_files[@]}"; do
          vmid=$(basename "$conf_file" .conf)

          if [[ "$subnet_prefix" == "8" ]]; then
              part1=${vmid:0:1}
              part2=${vmid:1:2}
              ip_pattern="$first_block_ip\.$part1\.$part2\.[0-9]\{1,3\}"
          else
              part1=${vmid:0:2}
              part2=${vmid:2}
              ip_pattern="$first_block_ip\.$second_block_ip\.$part1\.$part2[0-9]\{1,2\}"
          fi

          sed -i '/# DHCP Static leases/,/^[[:space:]]*$/ {
              /dhcp-host\s*=\s*[^,]*,'"${ip_pattern}"'/d
          }' /etc/dnsmasq.conf
      done

      # Step 5: Generate dhcp-host lines and store them in a variable
      new_dhcp_hosts=""
      for entry in "${entries[@]}"; do
          IFS='|' read -r net_num_only mac part1 part2 order_no <<< "$entry"

          if [[ "$subnet_prefix" == "8" ]]; then
              ip="$first_block_ip.$part1.$part2.$order_no"
          else
              ip="$first_block_ip.$second_block_ip.$part1.$part2$order_no"
          fi

          dhcp_line="dhcp-host=$mac,$ip"
          new_dhcp_hosts+="$dhcp_line"$'\n'
      done

      # Step 7: Use sed to insert/replace the DHCP static leases block with the new dhcp-host lines
      perl -0777 -pi -e 's/(?:(?:(?:[ \t\n]*)# DHCP Static leases\n)([\s\S]*?))?(?:[ \t\n]*)(\n\# Always allocate the host with Ethernet address (?:[A-Fa-f0-9]{2}:?){6}\n# The IP address (?:\d{1,3}\.?){4})/\n\n# DHCP Static leases$1\n'"$new_dhcp_hosts"'$2/s' /etc/dnsmasq.conf
      {% endraw %}

- name: "{{ file_sno_type_prefix }} 006: {{ section_name }}, Set execute permission on the script"
  file:
    path: "/usr/local/bin/dhcp_static_mappings_generator.sh"
    owner: root
    group: root
    mode: '0755'
    state: file

- name: "{{ file_sno_type_prefix }} 007: {{ section_name }}, Add cron job to run the script every 2 hours"
  cron:
    name: "Run `dhcp_static_mappings_generator.sh` script every 2 hours"
    user: root
    minute: "0"
    hour: "*/2"
    job: "/usr/local/bin/dhcp_static_mappings_generator.sh '{{ vmbr0B_iprange }}' >> /var/log/dhcp_static_mappings_generator.log 2>&1"

- name: "{{ file_sno_type_prefix }} 008: {{ section_name }}, Restart `dnsmasq` service"
  service:
    name: dnsmasq
    state: restarted

- name: "{{ file_sno_type_prefix }} 009: {{ section_name }}, Restart `networking` service"
  service:
    name: networking
    state: restarted

- name: "{{ file_sno_type_prefix }} 010: {{ section_name }}, Touching checksum file on successful completion"
  shell: "mkdir -p /root/proxmox_automation_install && rm -f /root/proxmox_automation_install/task_setting_up_lan_and_internet_bridge_* && sleep 2 && touch /root/proxmox_automation_install/task_setting_up_lan_and_internet_bridge_$(date +%Y%m%d-%H%M%S).run.tmp"
  changed_when: false

- name: "{{ file_sno_type_prefix }} 011: {{ section_name }}, Reboot the server if `is_condition_post_completion_tasks_and_cleanup` is not defined"
  reboot:
    msg: "Reboot initiated by Ansible for networking `interface` and dnsmasq server installation changes"
    reboot_timeout: 600
  when: 
    - is_condition_post_completion_tasks_and_cleanup is not defined
    - is_vmbr0_modified_in_interfaces.rc != 0 or is_vmbr0B_present_in_interfaces.rc != 0
